<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HotPic Frontend</title>
  <meta name="color-scheme" content="dark light">
  <style>
    :root { color-scheme: dark; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial;
      background: #0b0b0c; color: #e8e8ea;
    }
    header {
      padding: 12px 16px; position: sticky; top: 0;
      backdrop-filter: saturate(180%) blur(8px);
      background: rgba(11,11,12,0.72);
      border-bottom: 1px solid #1f2024; z-index: 10;
      display: flex; gap: 10px; align-items: center;
    }
    header h1 { margin: 0; font-size: 18px; font-weight: 700; }
    .status { font-size: 12px; color: #a7a9b4; margin-left: auto; }
    main { padding: 14px; }
    .controls, .toolbar { display:flex; gap:8px; align-items:center; margin-bottom: 12px; }
    input, button {
      border-radius: 8px; border: 1px solid #2a2b31; background:#121317; color:#e8e8ea;
      padding: 8px 10px;
    }
    button { cursor: pointer; }
    .grid {
      --min: 160px;
      display: grid; grid-template-columns: repeat(auto-fill, minmax(var(--min), 1fr)); gap: 10px;
    }
    .tile, .cell {
      position: relative; aspect-ratio: 3 / 4; border-radius: 12px; overflow: hidden;
      background: #141416; border: 1px solid #232429;
    }
    .tile img, .cell img, .cell video, .placeholder {
      width: 100%; height: 100%; object-fit: cover; display: block; background:#0f1013;
    }
    .overlay {
      position: absolute; left: 0; right: 0; bottom: 0;
      padding: 8px 10px; font-size: 12px; color: #e9e9ec;
      background: linear-gradient(to top, rgba(0,0,0,0.6), rgba(0,0,0,0));
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    .tile::after, .cell::after {
      content: ''; position: absolute; inset: 0;
      box-shadow: inset 0 0 0 0 rgba(255,255,255,0.08);
      transition: box-shadow .15s ease;
    }
    .tile:hover::after, .cell:hover::after { box-shadow: inset 0 0 0 2px rgba(99,102,241,0.9); }
    .actions { display:flex; justify-content:center; gap:8px; margin-top:12px; }
    .back { color:#9aa0ff; text-decoration:none; cursor:pointer; display:none; }
    .hidden { display:none; }
    /* Uploader extras */
    .preview img { margin-top: 10px; max-width: 100%; border-radius: 8px; display:block; }
    .result { margin-top: 8px; word-break: break-all; font-size: 12px; color:#c7c8d2; }
    @media (min-width: 1200px) { .grid { --min: 200px; } }
    @media (max-width: 420px) { .grid { --min: 140px; } }
  </style>
</head>
<body>
  <header>
    <a class="back" id="backBtn">← Back</a>
    <h1 id="title">HotPic</h1>
    <span class="status" id="status"></span>
  </header>

  <main>
    <div class="controls">
      <input id="apiBase" placeholder="Backend URL (e.g., https://your-app.onrender.com)" style="flex:1; max-width: 680px">
      <button id="loadHomeBtn">Load Home</button>
    </div>

    <div class="toolbar">
      <input id="searchBox" placeholder="Filter titles (client-side)" style="flex:1">
      <button id="clearSearch">Clear</button>
    </div>

    <div class="grid" id="grid"></div>
    <div class="actions">
      <button id="loadMoreBtn" class="hidden">Load more</button>
      <button id="downloadAllBtn" class="hidden">Download all</button>
    </div>
    <!-- Album uploader (visible only on second page / album view) -->
    <div id="uploader" class="hidden" style="max-width:680px; margin: 10px auto 0;">
      <div class="controls" style="justify-content:center;">
        <input type="file" id="imageInput" accept="image/*">
        <button id="uploadBtn">Upload to ImgBB</button>
      </div>
      <div class="preview" id="preview"></div>
      <div class="result" id="result"></div>

      <hr style="border:none; border-top:1px solid #232429; margin:16px 0;">

      <div id="upfilesUploader">
        <div class="controls" style="gap:8px; align-items:stretch;">
          <input id="upfAlias" placeholder="Folder alias (optional)" style="flex:1;">
          <input type="file" id="upfFile">
          <button id="upfUploadBtn">Upload to Upfiles</button>
        </div>
        <div class="result" id="upfStatus"></div>
        <div class="result" id="upfOutput"></div>
        <div class="actions" id="upfActions" style="display:none;">
          <button id="upfCopyBtn">Copy URL</button>
          <a id="upfViewBtn" href="#" target="_blank" rel="noopener" class="back">View File</a>
        </div>
      </div>
    </div>
    <!-- Forum iframe (visible only on second page / album view) -->
    <div id="forumFrame" class="hidden" style="max-width:680px; margin: 10px auto 0;">
      <iframe
        src="https://forum.sorrymother.top/forums/manyvids.90/post-thread"
        style="width:100%; height:600px; border: 1px solid #232429; border-radius: 12px; background:#141416;"
        loading="lazy"
        referrerpolicy="no-referrer"
        sandbox="allow-scripts allow-forms allow-same-origin"
      ></iframe>
    </div>
  </main>

  <script>
    // API base (behind Worker proxy) and media proxy base
    const DEFAULT_API_BASE = 'https://fragrant-tooth-c9f0.ykumawat006-372.workers.dev/?url=https://backend-automation-1.onrender.com';
    const PROXY_BASE = 'https://fragrant-tooth-c9f0.ykumawat006-372.workers.dev/?url='; // Cloudflare Worker proxy
    const PAGE_SIZE = 24;

    const apiBaseEl = document.getElementById('apiBase');
    const statusEl = document.getElementById('status');
    const titleEl = document.getElementById('title');
    const backBtn = document.getElementById('backBtn');
    const grid = document.getElementById('grid');
    const loadHomeBtn = document.getElementById('loadHomeBtn');
    const loadMoreBtn = document.getElementById('loadMoreBtn');
    const downloadAllBtn = document.getElementById('downloadAllBtn');
    const searchBox = document.getElementById('searchBox');
    const clearSearch = document.getElementById('clearSearch');
    // Uploader elements
    const uploader = document.getElementById('uploader');
    const forumFrame = document.getElementById('forumFrame');
    const imageInput = document.getElementById('imageInput');
    const uploadBtn = document.getElementById('uploadBtn');
    const preview = document.getElementById('preview');
    const result = document.getElementById('result');
    // Upfiles elements
    const upfAlias = document.getElementById('upfAlias');
    const upfFile = document.getElementById('upfFile');
    const upfUploadBtn = document.getElementById('upfUploadBtn');
    const upfStatus = document.getElementById('upfStatus');
    const upfOutput = document.getElementById('upfOutput');
    const upfActions = document.getElementById('upfActions');
    const upfCopyBtn = document.getElementById('upfCopyBtn');
    const upfViewBtn = document.getElementById('upfViewBtn');
    // ImgBB API key
    const IMGBB_API_KEY = '4e0db407007bbe40cb8fcc8fb0b8d19d';
    // Upfiles config (via CF Worker proxy)
    const UPFILES_TOKEN = '35b1297977d82a555a6044ed91f5f31a';
    const UPFILES_PROXY = 'https://cold-forest-9b60.ykumawat006-372.workers.dev/?proxyurl=';
    const UPFILES_UPLOAD_ENDPOINT = UPFILES_PROXY + 'https://api.upfiles.com/upload';
    // WebP to JPG conversion API
    const WEBP_TO_JPG_API = 'https://image-converter.ykumawat006-372.workers.dev/convert?img_url=';


    apiBaseEl.value = DEFAULT_API_BASE;

    function setStatus(msg) { statusEl.textContent = msg || ''; }
    function base() { return apiBaseEl.value.trim().replace(/\/+$/,''); }

    // Build proxied URL with cache-busting to avoid cached opaque responses
    function withProxy(rawUrl) {
      const bust = `_=${Date.now()}`;
      const u = rawUrl.includes('?') ? `${rawUrl}&${bust}` : `${rawUrl}?${bust}`;
      return PROXY_BASE + encodeURIComponent(u);
    } // Cloudflare Worker CORS proxy pattern [1][17]

    async function getJSON(pathAndQuery) {
      const url = base() + pathAndQuery;
      setStatus('Loading…');
      const res = await fetch(url, { credentials: 'omit' });
      let data;
      try { data = await res.json(); } catch { data = null; }
      if (!res.ok) throw new Error((data && (data.message || data.error)) || ('HTTP ' + res.status));
      setStatus('');
      return data;
    }

    // State for album pagination
    let albumItems = [];
    let albumIndex = 0;
    let currentAlbumOrigin = '';

    function applyFilter(items) {
      const q = searchBox.value.trim().toLowerCase();
      if (!q) return items;
      return items.filter(x => (x.title || '').toLowerCase().includes(q));
    }

    function renderHome(items) {
      grid.innerHTML = '';
      backBtn.style.display = 'none';
      uploader.classList.add('hidden');
      if (forumFrame) forumFrame.classList.add('hidden');
      titleEl.textContent = 'HotPic – Albums';
      loadMoreBtn.classList.add('hidden');
      downloadAllBtn.classList.add('hidden');

      const filtered = applyFilter(items);
      const frag = document.createDocumentFragment();

      filtered.forEach(({ href, thumb, title }) => {
        const a = document.createElement('a');
        a.className = 'tile'; a.href = '#';
        a.onclick = (e) => { e.preventDefault(); openAlbum(href); };

        if (thumb) {
          const img = document.createElement('img');
          img.src = thumb; img.alt = title || ''; img.loading = 'lazy';
          img.onerror = () => { img.style.display = 'none'; };
          a.appendChild(img);
        } else {
          const ph = document.createElement('div');
          ph.className = 'placeholder';
          a.appendChild(ph);
        }

        const ov = document.createElement('div');
        ov.className = 'overlay';
        ov.textContent = title || '';
        a.appendChild(ov);

        frag.appendChild(a);
      });

      grid.appendChild(frag);
    }

    function renderAlbumBatch() {
      const filtered = applyFilter(albumItems);
      const slice = filtered.slice(albumIndex, albumIndex + PAGE_SIZE);

      const frag = document.createDocumentFragment();
      slice.forEach(item => {
        const cell = document.createElement('div');
        cell.className = 'cell';

        if (item.kind === 'video') {
          const v = document.createElement('video');
          v.controls = true; v.preload = 'metadata';
          if (item.poster) v.setAttribute('poster', item.poster);
          const s = document.createElement('source');
          s.src = item.src; s.type = 'video/mp4';
          v.appendChild(s);
          cell.appendChild(v);
        } else {
          const img = document.createElement('img');
          img.src = item.src; img.alt = item.title || '';
          img.loading = 'lazy';
          img.onerror = () => { img.style.display = 'none'; };
          cell.appendChild(img);
        }

        const cap = document.createElement('div');
        cap.className = 'overlay';
        cap.textContent = item.title || '';
        cell.appendChild(cap);

        frag.appendChild(cell);
      });

      grid.appendChild(frag);

      albumIndex += PAGE_SIZE;
      if (albumIndex < filtered.length) loadMoreBtn.classList.remove('hidden');
      else loadMoreBtn.classList.add('hidden');

      downloadAllBtn.classList.remove('hidden');
    }

    async function loadHome() {
      grid.innerHTML = '';
      setStatus('Loading albums…');
      try {
        const data = await getJSON('/api/home');
        renderHome(Array.isArray(data.items) ? data.items : []);
      } catch (e) {
        setStatus('Failed: ' + e.message);
        grid.innerHTML = '<div class="cell"><div class="overlay">Failed to load albums</div></div>';
      } finally {
        if (!statusEl.textContent) setStatus('');
      }
    }

    async function openAlbum(href) {
      grid.innerHTML = '';
      backBtn.style.display = '';
      backBtn.onclick = () => { downloadAllBtn.classList.add('hidden'); uploader.classList.add('hidden'); if (forumFrame) forumFrame.classList.add('hidden'); loadHome(); };
      titleEl.textContent = 'Album';
      setStatus('Loading album…');
      loadMoreBtn.classList.add('hidden');
      downloadAllBtn.classList.add('hidden');
      uploader.classList.remove('hidden');
      if (forumFrame) forumFrame.classList.remove('hidden');
      preview.innerHTML = '';
      result.innerHTML = '';
      // reset Upfiles UI
      if (upfAlias) upfAlias.value = '';
      if (upfStatus) upfStatus.textContent = '';
      if (upfOutput) upfOutput.innerHTML = '';
      if (upfActions) upfActions.style.display = 'none';
      if (upfFile) upfFile.value = '';
      albumItems = [];
      albumIndex = 0;
      try { currentAlbumOrigin = new URL(href).origin; } catch { currentAlbumOrigin = ''; }

      try {
        const data = await getJSON('/api/album?u=' + encodeURIComponent(href));
        albumItems = Array.isArray(data.items) ? data.items : [];
        renderAlbumBatch(); // first page
        // Automatically start download-all (and subsequent ZIP upload)
        try { downloadAllCurrentAlbum(); } catch {}
      } catch (e) {
        setStatus('Failed: ' + e.message);
        grid.innerHTML = '<div class="cell"><div class="overlay">Failed to load album</div></div>';
      } finally {
        if (!statusEl.textContent) setStatus('');
      }
    }

    // JSZip + FileSaver loader
    async function ensureZipLibs() {
      if (!window.JSZip) {
        await new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
          s.crossOrigin = 'anonymous';
          s.referrerPolicy = 'no-referrer';
          s.onload = resolve;
          s.onerror = reject;
          document.head.appendChild(s);
        });
      }
      if (!window.saveAs) {
        await new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.src = 'https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js';
          s.crossOrigin = 'anonymous';
          s.referrerPolicy = 'no-referrer';
          s.onload = resolve;
          s.onerror = reject;
          document.head.appendChild(s);
        });
      }
    } // JSZip generateAsync + FileSaver pattern [11][12]

    // If the grid shows thumbs like /thumb/*.webp but overlay title has .jpg/.png,
    // reconstruct original image URL and use overlay title as filename
    function pickDownloadTarget(it) {
      const title = (it.title || '').trim();
      if (it.kind === 'video') {
        return { url: resolveAbsoluteUrl(it.src), name: title || null };
      }
      try {
        const abs = resolveAbsoluteUrl(it.src);
        const u = new URL(abs);
        const parts = u.pathname.split('/');
        const idx = parts.indexOf('thumb');
        if (idx !== -1 && title && /\.(jpe?g|png|webp|gif)$/i.test(title)) {
          // remove 'thumb' folder and replace last segment with the title filename
          parts.splice(idx, 1);
          parts[parts.length - 1] = title;
          u.pathname = parts.join('/');
          return { url: u.toString(), name: title };
        }
      } catch {}
      return { url: resolveAbsoluteUrl(it.src), name: title || null };
    } // Rebuild original image URL from thumbnail path [18]

    function resolveAbsoluteUrl(raw) {
      if (!raw) return '';
      try { return new URL(raw).toString(); } catch {}
      try {
        if (raw.startsWith('//')) return 'https:' + raw;
        if (currentAlbumOrigin) return new URL(raw, currentAlbumOrigin).toString();
      } catch {}
      return raw;
    }

    function extFromMime(mime) {
      if (!mime) return '';
      const t = mime.toLowerCase();
      if (t === 'image/jpeg' || t === 'image/jpg') return 'jpg';
      if (t === 'image/png') return 'png';
      if (t === 'image/webp') return 'webp';
      if (t === 'image/gif') return 'gif';
      if (t === 'video/mp4') return 'mp4';
      if (t === 'video/webm') return 'webm';
      return (t.includes('/') ? t.split('/')[1] : '').replace('jpeg','jpg');
    }

    async function fetchAsBlobViaProxy(rawUrl) {
      const bust = `_=${Date.now()}`;
      const u = rawUrl.includes('?') ? `${rawUrl}&${bust}` : `${rawUrl}?${bust}`;
      const res = await fetch(PROXY_BASE + encodeURIComponent(u), { credentials: 'omit' });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return { blob: await res.blob(), headers: res.headers };
    } // Proxy avoids CORS blocks [1][17]

    // Check if URL points to an image (any format)
    function isImage(url) {
      try {
        const u = new URL(url);
        const pathname = u.pathname.toLowerCase();
        return pathname.match(/\.(jpg|jpeg|png|gif|webp|bmp|tiff)$/);
      } catch {
        return url.toLowerCase().match(/\.(jpg|jpeg|png|gif|webp|bmp|tiff)$/);
      }
    }

    // Check if URL points to a WebP image specifically
    function isWebPImage(url) {
      try {
        const u = new URL(url);
        const pathname = u.pathname.toLowerCase();
        return pathname.includes('.webp') || pathname.includes('webp');
      } catch {
        return url.toLowerCase().includes('.webp') || url.toLowerCase().includes('webp');
      }
    }

    // Check if URL points to a JPG image specifically
    function isJPGImage(url) {
      try {
        const u = new URL(url);
        const pathname = u.pathname.toLowerCase();
        return pathname.match(/\.(jpg|jpeg)$/);
      } catch {
        // Handle URLs with query parameters by checking before the '?' or '#'
        const cleanUrl = url.toLowerCase().split('?')[0].split('#')[0];
        return cleanUrl.match(/\.(jpg|jpeg)$/);
      }
    }

    // Convert any image to JPG using the conversion API
    async function convertImageToJPG(imageUrl) {
      const conversionUrl = WEBP_TO_JPG_API + imageUrl;
      console.log('Converting image via API:', conversionUrl);
      
      const res = await fetch(conversionUrl, { credentials: 'omit' });
      if (!res.ok) throw new Error(`Conversion failed: HTTP ${res.status}`);
      
      // Try to parse as JSON first to check for download_url
      let blob, filename;
      const contentType = res.headers.get('content-type');
      
      if (contentType && contentType.includes('application/json')) {
        // Response is JSON, try to get download_url
        const data = await res.json();
        console.log('Got JSON response:', data);
        
        if (data.success && data.download_url) {
          // Use download_url if available
          console.log('Using download_url:', data.download_url);
          const proxiedDownloadUrl = PROXY_BASE + encodeURIComponent(data.download_url);
          const downloadRes = await fetch(proxiedDownloadUrl, { credentials: 'omit' });
          if (!downloadRes.ok) throw new Error(`Download failed: HTTP ${downloadRes.status}`);
          
          blob = await downloadRes.blob();
          filename = data.filename || null;
          console.log('Downloaded from download_url successfully');
        } else {
          throw new Error('Conversion API returned unsuccessful response or no download_url');
        }
      } else {
        // Response is direct image blob
        console.log('Got direct image blob from API');
        blob = await res.blob();
        
        // Generate filename based on the original URL
        const urlParts = imageUrl.split('/');
        const originalFilename = urlParts[urlParts.length - 1] || 'converted-image.jpg';
        filename = originalFilename.replace(/\.(webp|png|gif|bmp|tiff|jpeg)$/i, '.jpg');
      }
      
      return { 
        blob: blob, 
        headers: res.headers,
        filename: filename
      };
    }

    function safeNameFromUrl(url, idx, extHint='') {
      try {
        const u = new URL(url);
        let name = u.pathname.split('/').pop() || `file-${idx}`;
        // strip query/hash if present
        name = name.split('?')[0].split('#')[0];
        // sanitize illegal filename characters
        name = name.replace(/[\/:*?"<>|]/g, '_');
        if (!/\.[a-z0-9]{2,5}$/i.test(name) && extHint) name = `${name}.${extHint}`;
        return name || `file-${idx}${extHint ? '.'+extHint : ''}`;
      } catch {
        return `file-${idx}${extHint ? '.'+extHint : ''}`;
      }
    }

    async function downloadAllCurrentAlbum() {
      const filtered = applyFilter(albumItems);
      if (!filtered.length) { setStatus('No items to download'); return; }

      downloadAllBtn.disabled = true;
      loadMoreBtn.disabled = true;
      backBtn.style.pointerEvents = 'none';

      try {
        await ensureZipLibs();
        setStatus(`Preparing ${filtered.length} files…`);

        const zip = new window.JSZip();
        let ok = 0, fail = 0;

        for (let i = 0; i < filtered.length; i++) {
          const it = filtered[i];
          const target = pickDownloadTarget(it);
          try {
            let blob, headers, fname;
            
            // Convert all images to JPG using the conversion API
            if (it.kind !== 'video' && isImage(target.url)) {
              // Send all image URLs to the WebP to JPG API for conversion
              setStatus(`Converting image to JPG ${i+1}/${filtered.length}…`);
              const result = await convertImageToJPG(target.url);
              blob = result.blob;
              headers = result.headers;
              
              // Use filename from conversion API if available, otherwise use original name
              if (result.filename) {
                fname = result.filename;
              } else if (target.name) {
                // Convert any image extension to .jpg
                fname = target.name.replace(/\.(webp|png|gif|bmp|tiff|jpeg)$/i, '.jpg');
              } else {
                fname = safeNameFromUrl(target.url, i+1, 'jpg');
              }
            } else {
              // For videos, download directly without conversion
              const result = await fetchAsBlobViaProxy(target.url);
              blob = result.blob;
              headers = result.headers;
              
              fname = target.name;
              const cd = headers.get('content-disposition');
              if (!fname && cd) {
                const m = /filename\\*?=(?:UTF-8''|\"?)([^\";]+)/i.exec(cd);
                if (m) fname = decodeURIComponent(m[1].replace(/\"/g,''));
              } // Prefer Content-Disposition filename when present [20]
              
              // For videos, use original extension
              const typeExt = extFromMime(blob.type);
              const fallbackExt = it.kind === 'video' ? 'mp4' : 'jpg';
              if (!fname) fname = safeNameFromUrl(target.url, i+1, typeExt || fallbackExt);
            }
            
            zip.file(fname, blob);
            ok++;
            setStatus(`Added ${ok}/${filtered.length}…`);
            await new Promise(r => setTimeout(r, 0));
          } catch (e) {
            fail++;
            console.warn('Skip', target.url, e);
            setStatus(`Added ${ok}/${filtered.length} (skipped ${fail})…`);
          }
        }

        setStatus('Zipping…');
        const zipBlob = await zip.generateAsync({
          type: 'blob',
          compression: 'DEFLATE',
          compressionOptions: { level: 6 }
        }, (meta) => {
          setStatus(`Zipping… ${Math.round(meta.percent)}%`);
        }); // Progress callback [11]

        const albumLabel = (titleEl.textContent || 'album').toLowerCase().replace(/\s+/g,'-');
        const zipFileName = `${albumLabel || 'album'}.zip`;
        window.saveAs(zipBlob, zipFileName);

        // After saving locally, also upload the ZIP to Upfiles automatically
        try {
          const zipFile = new File([zipBlob], zipFileName, { type: 'application/zip' });
          if (upfStatus) upfStatus.textContent = 'Uploading ZIP…';
          await uploadToUpfiles(zipFile);
          setStatus(`Download ready and ZIP uploaded (${ok} files, ${fail} skipped)`);
        } catch (uploadErr) {
          console.error(uploadErr);
          setStatus(`Download ready (${ok} files, ${fail} skipped). ZIP upload failed.`);
        }
      } catch (e) {
        console.error(e);
        setStatus('Download failed: ' + (e && e.message ? e.message : 'unknown error'));
      } finally {
        downloadAllBtn.disabled = false;
        loadMoreBtn.disabled = false;
        backBtn.style.pointerEvents = '';
      }
    }

    // Wire up UI
    loadHomeBtn.onclick = loadHome;
    loadMoreBtn.onclick = renderAlbumBatch;
    downloadAllBtn.onclick = downloadAllCurrentAlbum;

    // Upload handler (album page)
    if (uploadBtn) {
      uploadBtn.onclick = async () => {
        const imageFile = imageInput && imageInput.files && imageInput.files[0];
        if (!imageFile) { alert('Please select an image first.'); return; }
        preview.innerHTML = `<img src="${URL.createObjectURL(imageFile)}" alt="preview">`;

        const formData = new FormData();
        formData.append('image', imageFile);
        result.textContent = 'Uploading…';
        try {
          const response = await fetch(`https://api.imgbb.com/1/upload?key=${IMGBB_API_KEY}`);
          // Some CDNs require body last; ensure POST with body
        } catch {}
        try {
          const response = await fetch(`https://api.imgbb.com/1/upload?key=${IMGBB_API_KEY}`, {
            method: 'POST',
            body: formData
          });
          const data = await response.json();
          if (data && data.success) {
            const url = data.data && (data.data.url || data.data.display_url);
            result.innerHTML = `✅ Uploaded Successfully! <br><a href="${url}" target="_blank">${url}</a>`;
          } else {
            const msg = data && data.error && (data.error.message || data.error) || 'Upload failed';
            result.textContent = '❌ Upload Failed: ' + msg;
          }
        } catch (e) {
          console.error(e);
          result.textContent = '⚠️ Error: ' + (e && e.message ? e.message : 'unknown error');
        }
      };
    }

    // Upfiles upload handler (album page)
    async function uploadToUpfiles(file) {
      if (!file) { alert('Please select a file first.'); return; }
      if (upfStatus) upfStatus.textContent = 'Uploading…';
      if (upfOutput) upfOutput.innerHTML = '';
      if (upfActions) upfActions.style.display = 'none';

      const formData = new FormData();
      formData.append('token', UPFILES_TOKEN);
      formData.append('file', file);
      const alias = (upfAlias && upfAlias.value || '').trim();
      if (alias) formData.append('folder_alias', alias);

      try {
        const res = await fetch(UPFILES_UPLOAD_ENDPOINT, { method: 'POST', body: formData });
        const data = await res.json();
        if (data && data.status === 'success' && data.url) {
          const proxiedUrl = UPFILES_PROXY + data.url;
          if (upfStatus) upfStatus.textContent = '✅ Upload Successful';
          if (upfOutput) upfOutput.innerHTML = `<a href="${proxiedUrl}" target="_blank" rel="noopener">${proxiedUrl}</a>`;
          if (upfViewBtn) upfViewBtn.href = proxiedUrl;
          if (upfActions) upfActions.style.display = '';
          if (upfCopyBtn) {
            upfCopyBtn.onclick = async () => {
              try { await navigator.clipboard.writeText(proxiedUrl); setStatus('Copied'); setTimeout(() => setStatus(''), 800); } catch {}
            };
          }
        } else {
          const msg = (data && (data.message || data.error)) || 'Upload failed';
          if (upfStatus) upfStatus.textContent = '❌ ' + msg;
        }
      } catch (e) {
        if (upfStatus) upfStatus.textContent = '⚠️ Error: ' + (e && e.message ? e.message : 'network error');
      }
    }

    if (upfUploadBtn && upfFile) {
      upfUploadBtn.onclick = () => uploadToUpfiles(upfFile.files && upfFile.files[0]);
      upfFile.onchange = () => { if (upfFile.files && upfFile.files[0]) uploadToUpfiles(upfFile.files[0]); };
    }

    searchBox.oninput = () => {
      const onAlbum = backBtn.style.display !== 'none';
      grid.innerHTML = '';
      if (onAlbum) {
        albumIndex = 0;
        renderAlbumBatch();
      } else {
        loadHome();
      }
    };
    clearSearch.onclick = () => { searchBox.value = ''; searchBox.oninput(); };

    // Auto-load when API base is present
    if (apiBaseEl.value.trim() !== '') loadHome();
  </script>
</body>
</html>




